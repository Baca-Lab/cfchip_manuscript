library(rtracklayer)
library(GenomicRanges)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(data.table)
library(readxl)

# TODO: remove libraries that are not needed
# This analysis searches for regions of the genome where cfChIP-seq signal is correlated (or anticorrelated) with ctDNA content. 
# Correlated regions are expected to represent sites that are marked in cancer more so than in healthy. 
# Inversely correlated regions may correspond to sites that are marked in healty-derived nucleosomes but NOT cancer.


# function to identify CREs
test_CREs = function(counts, # normalized counts matrix generated by frag_counts()
                     meta, # metadatasheet with columns specifieid below
                     hold_out = NA, # study_name of sample to hold out, or NA
#                     this_type_only = NA, # consider only samples with cancer_type == this_type_only
                     corr_qvalue_threshold = 0.05,
                     top_n_by_sig,
                     trim_top_quantile = 0, #when calculating CRE signal, remove this top quantile of CREs by signal
                     filter_enrichment = 10, # for training, only use samples wtih enrichment > this value in metadata
                     filter_fragments = 2e6, # for training, only use samples wtih fragments > this value in metadata
                     reset_low_ctDNA = FALSE # should ctDNA values < 0.03 be set to 0.03? This is done to reduce noise in the low ctDNA range for Spearman correlation
) {

  # make sure all the required columns are present in the metasheet
  stopifnot(c('study_name', 'individual_id', 'enrichment', 'ctDNA', 'fragments') %in% colnames(meta))

  if(reset_low_ctDNA) {
    meta$ctDNA[!is.na(meta$ctDNA) & meta$ctDNA < 0.03]  = 0.03
  }
  # if there are multiple samples for an individual, only train on the one with the most fragments
  tmp = meta %>% group_by(individual_id) %>% slice_max(order_by = fragments) %>% dplyr::select(study_name)
  training = tmp$study_name
  
  if (!is.na(hold_out)) {
    # if a holdout sample is specified, remove it and samples from the same individual
    stopifnot(hold_out %in% meta$study_name &
                hold_out %in% colnames(counts))
    this_sample = meta$study_name[meta$individual_id == meta$individual_id[meta$study_name == hold_out]]
    training = setdiff(training, this_sample)
  }
  
  training = intersect(training, colnames(counts))
  training = training[training %in% meta$study_name[!is.na(meta$ctDNA) &
                                                      (meta$antibody == 'MeDIP' | meta$enrichment > filter_enrichment) &
                                                      meta$fragments > filter_fragments]]


  # keep only the relevant samples
  counts_subset = counts[, colnames(counts) %in% training]
  ctDNA = meta$ctDNA[meta$study_name %in% colnames(counts_subset)]
  
  # make sure the study names line up as expected between the counts matrix and ctDNA info from the metadata
  stopifnot(colnames(counts_subset) == meta$study_name[meta$study_name %in% colnames(counts_subset)])


  corr_results = apply(counts_subset, 1,
                       function(x) {
                         tmp = cor.test(x, ctDNA, method = 'spearman')
                         c(tmp$estimate, tmp$p.value, mean(x))
                       }) %>%
    suppressWarnings() %>%
    t() %>%
    as.data.frame()
  
  colnames(corr_results) = c('rho', 'p.value', 'mean_signal')
  corr_results$q.value = p.adjust(corr_results$p.value, method = 'fdr')
  corr_results$significant = corr_results$q.value < corr_qvalue_threshold

  neg_CREs = corr_results %>% subset(rho < 0) %>% slice_min(n = top_n_by_sig, order_by =
                                                              p.value, with_ties = FALSE) %>% rownames()
  pos_CREs = corr_results %>% subset(rho > 0) %>% slice_min(n = top_n_by_sig, order_by =
                                                              p.value, with_ties = FALSE) %>% rownames()

  ret = list(neg_CREs, pos_CREs, corr_results)
  names(ret) = c('neg_CREs', 'pos_CREs', 'corr_results')
  
  if (!is.na(hold_out)) {
    # calculate signal at the CREs
    
  } else {
    #calculate signal for all samples
    # only consider CREs with signal < the specified cutoff
    pos_CRE_mat = counts[pos_CREs,]
    pos_CRE_mat_sum = rowSums(pos_CRE_mat)
    pos_cut = quantile(pos_CRE_mat_sum, probs = 1 - trim_top_quantile)
    pos_CRE_mat = pos_CRE_mat[pos_CRE_mat_sum < pos_cut,]
    
    neg_CRE_mat = counts[neg_CREs,]
    neg_CRE_mat_sum = rowSums(neg_CRE_mat)
    neg_cut = quantile(neg_CRE_mat_sum, probs = 1 - trim_top_quantile)
    neg_CRE_mat = neg_CRE_mat[neg_CRE_mat_sum < neg_cut,]
    
    toadd = data.frame(
      study_name = colnames(counts),
      pos_CRE_signal = colSums(pos_CRE_mat),      
      neg_CRE_signal = colSums(neg_CRE_mat)
    )
    ret = c(ret, toadd)
  }
  ret
}


